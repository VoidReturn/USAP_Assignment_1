#!/bin/bash

#global variables
#the results.txt file is used for storing found passwords; common and dict are used to store respective lists of passwords to test
RESULTS="results.txt"
COMMON="common_passwords.txt"
DICT="linux.words"
#SLEEP_TIME sets how long the script wait between each test; RUN_LIMIT is the number of iterations before the script should abort a test
#these are currently set at 0.1 and 1200 to producde a run time of 2 minutes
SLEEP_TIME=0.1
RUN_LIMIT=1200


#####################################################
#				SCRIPT FUNCTIONS					#
#				MAIN BODY AT BOTTOM					#
#####################################################
#function for comparing a supplied password hash against a supplied password list
#supplied arguements should be username passwordhash passwordlist
#note: this function will be used for both the common passwords attack and the dictionary attack
pass_comparison() {
	if [ $# -lt 3 ]; then
		echo "invalid function argument"
		return 1
	fi
	pass_list="$3"
	test_cutoff=0
	#loop through each line of the supplied file
	while read -r test;  do
		#format the test password into lowercase
		formatted_test=${test,,}

		#test wether the iteration limit has been reached
		if [ $test_cutoff -gt $RUN_LIMIT ]; then
			echo "testing limit reached; aborting attack"
			return 1;
		fi

		#convert the current test password into a hash and then compare against supplied password hash
		test_hash=$(echo -n "$formatted_test"|sha256sum|awk '{print $1}')
		#echo "trying $test"
		if [ "$test_hash" == "$password" ]; then
			echo "MATCH!"
			echo "$username $test $password" >> $RESULTS
			return 0
		fi

		#increment limit counter and then wait for SLEEP_TIME
		let "test_cutoff++"
		sleep $SLEEP_TIME
	done < "$pass_list";
}

#brute force attack; using nested for loops like this is rather unwieldly but keeps things a little more concise i think
#each loop deeper adds another character to the end of the test string
brute_attack() {
	test_cutoff=0
    for first in {a..z}; do
		test_hash=$(echo -n "$first"|sha256sum|awk '{print $1}')
		#echo "$test"
		if [ "$test_hash" == "$password" ]; then
			match="$first"
			echo "single char match $match"
			echo "$username $match $password" >> $RESULTS
			return 0;
		fi
		let "test_cutoff++"
		for second in {a..z}; do
			test_hash=$(echo -n "$first$second"|sha256sum|awk '{print $1}')
			#echo "$test"
			if [ "$test_hash" == "$password" ]; then
				match="$first$second"
				echo "double char match $match"
				echo "$username $match $password" >> $RESULTS
				return 0;
			fi		
			let "test_cutoff++"
			for third in {a..z}; do
				test_hash=$(echo -n "$first$second$third"|sha256sum|awk '{print $1}')
				#echo "$test"
				if [ "$test_hash" == "$password" ]; then
					match="$first$second$third"
					echo "triple char match $match"
					echo "$username $match $password" >> $RESULTS
					return 0;
				fi
				let "test_cutoff++"
				for fourth in {a..z}; do
					 if [ $test_cutoff -gt $RUN_LIMIT ]; then
						echo "testing limit reached; aborting attack"
						return 1;
					fi
					test_hash=$(echo -n "$first$second$third$fourth"|sha256sum|awk '{print $1}')
					#echo "$test"
					if [ "$test_hash" == "$password" ]; then
						match="$first$second$third$fourth"
						echo "quadruple char match $match"
						echo "$username $match $password" >> $RESULTS
						return 0;
					fi
					let "test_cutoff++"
				done
			done
		done
	done
}

#####################################################
#				MAIN BODY OF SCRIPT					#
#####################################################
#clear out the results.txt file of any previous matchs
echo "Username Password Hash" > $RESULTS
echo "reading file..."
while IFS=':' read -r username password <&0; do
	#run each test for the current user:passwordhash combination
	echo "testing $username against common passwords"
	pass_comparison $username $password $COMMON
	#test if the password has already been found before moving onto the next test
	if grep "$username" $RESULTS; then
		continue
	fi 
	echo "testing $username against dictionary"
	pass_comparison $username $password $DICT
	if grep "$username" $RESULTS; then
		continue
	fi 
	echo "testing $username against brute force"
	brute_attack $username $password
done

echo "printing results"
while read -r match; do
	echo "$match"
done < $RESULTS
